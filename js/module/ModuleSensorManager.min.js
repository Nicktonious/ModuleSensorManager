class ClassSensorManager{constructor(){if(this.Instance)return this.Instance;ClassSensorManager.prototype.Instance=this,this._EqualityPercent=.05,this._Devices=[],Object.on("sensor-start-polling",_arg=>{let freq=_arg[0];this._Interval||this.StartPolling(freq)}),Object.on("sensor-stop-polling",()=>{this.StopPolling()}),Object.on("sensor-get-info",()=>{this.GetSensorsInfo()}),Object.on("sensor-write",_arg=>{this.ExecuteCom(_arg)}),Object.on("new-device",device=>{this.AddDevice(device)}),this.InitBuses()}get Devices(){return this._Devices}get Sensors(){return this._Devices.filter(device=>"sensor"===device._Type.toLowerCase())}set EqualityPercent(val){return val>0&&val<1&&(this._EqualityPercent=val,!0)}InitBuses(){let config=Process.GetBusesConfig();for(let busName of Object.keys(config)){let opts=config[busName],busObj;for(let option of Object.keys(opts))"bitrate"!==option&&(opts[option]=this.GetPinByStr(opts[option]));busName.startsWith("I2C")&&(busObj=I2Cbus.AddBus(opts)),busName.startsWith("SPI")&&(busObj=SPIbus.AddBus(opts)),busName.startsWith("UART")&&(busObj=UARTbus.AddBus(opts))}}AddDevice(device){!this.GetDevice(device.ID)&&device.ID&&this._Devices.push(device)}GetDevice(id){return this._Devices.find(dev=>dev.ID===id)}GetDeviceChannel(chId){let id=chId.split("-"),chNum=+id.pop(),device=this.GetDevice(id.join("-"));return device?device.GetChannel(chNum):null}StartPolling(_freq){const freq=_freq||4;if("number"!=typeof freq||freq<=0)return!1;const valIsEqual=(a,b)=>a===b||Math.abs(a-b)<=a*this._EqualityPercent;let data_cache={};return this._Interval=setInterval(()=>{let data_package={};this.Sensors.map(sensor=>{sensor._Channels.forEach(ch=>{valIsEqual(ch.Value,data_cache[ch.ID])||(data_package[ch.ID]=ch.Value,data_cache[ch.ID]=ch.Value)})}),Object.keys(data_package).length&&this.SendData(data_package)},1/freq*1e3),!0}StopPolling(){this._Interval&&clearInterval(this._Interval),this._Interval=null}GetSensorsInfo(){let data_package={MetaData:"Info",Value:[]};this.Devices.forEach(device=>{let sensor_info={},propsList;("sensor"===device._Type?["_Name","_Type","_QuantityChannel","_ChannelNames","_MinRange","_MaxRange","_TypeInSignal","_TypeOutSignal","_BusTypes","_ManufacturingData","_IsChUsed","_IsAvailable"]:"actuator"===device._Type?["_Name","_Type","_QuantityChannel","_ChannelNames","_MinRange","_MaxRange","_TypeInSignals","_BusTypes","_ManufacturingData","_IsChOn","_Offsets"]:[]).forEach(prop=>{sensor_info[prop]=device[prop]}),data_package.Value.push(sensor_info)}),this.SendData(data_package)}SendData(dataPackage){Object.emit("sensor-data",dataPackage)}SendInfo(infoArray){Object.emit("sensor-info",infoArray)}ExecuteCom(arg){let id=arg.shift(),methodName=arg.shift(),device=this.GetDeviceChannel(id);return!!device&&("function"==typeof device[methodName]&&(device[methodName].apply(device,arg),!0))}IsIDUnique(_id){return!Boolean(this.Devices.find(device=>device.ID===_id))}ArePinsAvailable(_pins){for(let i=0;i<_pins.length;i++)if(this.Devices.find(device=>device._Pins.includes(_pins[i])))return!1;return!0}CreateDevice(id,opts){if(opts=opts||{},"string"!=typeof id)return void console.log("ERROR>> id argument must to be a string");let sensorConfig=Process.GetDeviceConfig(id);if(!sensorConfig)return void console.log(`ERROR>> Failed to get ${id} config"`);let module=Process.ImportDeviceModule(sensorConfig.name,opts.moduleNum);if(!module)return void console.log(`ERROR>> Cannot load ${sensorConfig.module}"`);if(!this.IsIDUnique(id))return void console.log(`ERROR>> Id ${id} is already used`);if(sensorConfig.bus&&(sensorConfig.bus.startsWith("I2C")?sensorConfig.bus=I2Cbus._I2Cbus[sensorConfig.bus].IDbus:sensorConfig.bus.startsWith("SPI")?sensorConfig.bus=SPIbus._SPIbus[sensorConfig.bus].IDbus:sensorConfig.bus.startsWith("UART")&&(sensorConfig.bus=SPIbus._UARTbus[sensorConfig.bus].IDbus)),sensorConfig.pins=sensorConfig.pins||[],sensorConfig.pins=sensorConfig.pins.map(strPin=>this.GetPinByStr(strPin)),sensorConfig.id=id,!this.ArePinsAvailable(sensorConfig.pins))return void console.log(`ERROR>> Pins [${opts.pins.join(", ")}] are already used`);let device=new module(sensorConfig,sensorConfig);return this.AddDevice(device),device._Channels}GetPinByStr(strPin){let p;try{p=eval(strPin)}catch(e){}if(p instanceof Pin)return p;throw new Error(`ERROR>> Pin ${p} doesn't exist`)}}exports=ClassSensorManager;